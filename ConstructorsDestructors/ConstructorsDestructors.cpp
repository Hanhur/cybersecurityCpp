/*
    После создания объектов
    типа stack, мы вызываем функцию init() для каждого объекта, которая выполняет
    инициализацию стека, а именно устанавливает tos в О. Если этого
    не сделать, значение tos не будет определено и дальше все зависит от компилятора.
    Некоторые могут инициализировать переменную, установив ее в
    О, некоторые же ничего не будут делать, тогда ошибка времени выполнения
    гарантирована.

    Было бы хорошо, чтобы функция инициализации вызывалась автоматически.
    Ведь вы можете легко забыть ее вызвать или вызвать, но не для всех
    объектов - для s1, например, вызовите, а для s2 - забудете. Да и вообще это
    неудобно - вызывать функцию инициализации вручную.

    Разработчики языка С++ также так думаю, поэтому они разработали
    конструкторы и деструкторы. Конструктор класса вызывается всякий раз
    при создании объекта этого класса. Код нашей функции init идеально бьшо
    бы поместить в конструктор класса - тогда вы никогда не забудете инициализировать
    объект.

    Функция-конструктор называется так же, как и класс.

    stack: : stack ()
    {
    }

    // Имя деструктора предваряется тильдой ~:

    stack:: ~stack ()
    {
    }

    Обратите внимание: теперь init() можно не вызывать, но саму
    функцию init() я оставил в классе - вдруг понадобится в процессе работы
    со стеком выполнить заново инициализацию. Инициализация стека осуществляется
    автоматически с помощью конструктора. Деструктор просто
    выводит сообщение о том, что он работает - для демонстрации его возможностей
    (в нашей простой программе в нем нет необходимости).
*/

// Стек с конструктором и деструктором

#include <iostream>
using namespace std;

const int SIZE = 26;

class stack {
    char stck[SIZE];
    int tos;
    public:
        stack();
        ~stack();
        void init () ;
        void push(char ch);
        char pop();
};

stack::stack()
{
    cout << "Инициализируем стек\n";
    tos = 0;
}

stack::~stack()
{
    cout << "Работает деструктор ... \n";
}

void stack::init()
{
    tos = 0;
}

void stack::push(char ch)
{
    if (tos == SIZE) 
    {
        cout << "Стек полон!" << endl;
        return;
    }

    stck[tos] = ch;
    tos++;
}

char stack::pop()
{
    if (tos == 0) 
    {
        cout << "Стек пуст" << endl;
        return 0;
    }

    tos--;
    return stck[tos];
}

int main()
{
    stack s1, s2;
    int i;
    s1.push('a') ;
    s2.push('b') ;
    s1.push('c');
    s2.push('d') ;
    s1.push('e');
    s2. push ('f') ;
    for (i = 0; i < 3; i++) cout << s1.pop() << " ";
        cout << endl;
    for (i = 0; i < 3; i++) cout << s2.pop() << " ";
        cout << endl;
}


/*
    Конструкторы могут принимать параметры. Это свойство конструкторов мы
    будем использовать для идентификации стеков. Мы добавим еще один член
    - stackID типа int, затем добавим параметр id к нашему конструктору:

    stack::stack(int id)
    {
        stackID = id;
        cout << "Инициализируем стек " << stackID << endl;
        tos = 0;
    }

    Конструктор устанавливает ID стека и выводит информацию об этом. Аналогично, деструктор будет выглядеть так:
    stack::~stack()
    {
        cout << "Деструктор стека #" << stackID << " выполняется ... \n";
    }

    Инициализация объектов типа stack будет выглядеть так:
    stack s1(1), s2(2);
*/
